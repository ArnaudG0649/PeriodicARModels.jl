using Optimization, Dates, Statistics, StatsBase, DataFrames, LinearAlgebra, OptimizationOptimJL, ForwardDiff #,Zygote


function FillByDiags!(v, Indexes, d)
    return (diagm(((i => v[Indexes[-i+1]+1:Indexes[-i+2]]) for i in -(d - 1):0)...))
end

function FillByDiags(v, d)
    Indexes = [0; cumsum(d:-1:1)]
    return (FillByDiags!(v, Indexes, d))
end

"""
    Opp_Log_Likelihood_AR(x::AbstractVector,Estimators::AbstractVector)

Return the opposite of the log-likelihood of the x matrix-series, under the hypothesis that x is generated by an multiple AR(p) 
(model with Φ₁,Φ₂...Φₚ=Estimators[1:end-1], σ²=Estimators[end] and ε ~N(0,1). )
(Caution : it is the only function where Estimators[end]=σ². In the all others functions Estimators[end]=σ.
This function does not consider the likelihood of the initial conditiion x₁,x₂...xₚ)
"""
function Opp_LL_Multi_AR!(Estimators::AbstractVector, x::AbstractArray)
    n, d = size(x)
    p = (2 * length(Estimators) - d^2 - d) ÷ (2 * d^2)
    Φ = [stack(Estimators[(j*(d^2)+1+i*d):(j*(d^2)+(i+1)*d)] for i in 0:(d-1)) for j in 0:(p-1)]
    Indexes = [0; cumsum(d:-1:1)]
    Σ = FillByDiags!(Estimators[(p*d^2+1):end], Indexes, d)
    Varcov = (Σ * transpose(Σ))
    InvVarcov = inv(Varcov)
    cte = d * log(2π) + log(abs(det(Varcov)))
    EV(t) = sum(Φ[j] * x[t-j, :] for j in 1:p)
    Opplogpdf(t) = (cte + transpose(x[t, :] - EV(t)) * InvVarcov * (x[t, :] - EV(t))) / 2
    return Opplogpdf, p, n
end


function Opp_LL_Multi_AR(Estimators::AbstractVector, x::AbstractArray)
    Opplogpdf, p, n = Opp_LL_Multi_AR!(Estimators, x)
    return sum(Opplogpdf.((p+1):n))
end

"""
    LL_Multi_AR_Estimation(x::AbstractVector,p::Integer)

Return the parameters of the AR(p) model on x, estimated with likelihood computation.
Estimators correspond to the initialization of the algorithm.
"""
function LL_Multi_AR_Estimation(x::AbstractArray, p::Integer, Estimators=nothing, algo=LBFGS())
    d = size(x)[2]
    InitΣ = [1e-5 * ones(d); 1e-15 * ones(d * (d - 1) ÷ 2)]
    isnothing(Estimators) ? Estimators = [[0.5 for _ in 1:p*d^2]; InitΣ] : nothing
    # p == length(Estimators) - 1 ? nothing : error("p (=$(p)) is not equal to the number of Φ initial parameters (=$(length(Estimators)-1))")
    optf = OptimizationFunction(Opp_LL_Multi_AR, AutoForwardDiff())
    prob = OptimizationProblem(optf, Estimators, x, lb=[[-10 for _ in 1:p*d^2]; [1e-20 for _ in 1:(d*(d+1)÷2)]], ub=[[10 for _ in 1:p*d^2]; [1e2 for _ in 1:(d*(d+1)÷2)]])
    Results = Optimization.solve(prob, algo) #maxiters should be modified if needed
    return Results
end


##### Monthly Estimation ######

"""
    Opp_Log_Likelihood_AR(x::AbstractVector,Estimators::AbstractVector)

Return the opposite of the log-likelihood of the x matrix-series, under the hypothesis that x is generated by an multiple AR(p) 
(model with Φ₁,Φ₂...Φₚ=Estimators[1:end-1], σ²=Estimators[end] and ε ~N(0,1). )
(Caution : it is the only function where Estimators[end]=σ². In the all others functions Estimators[end]=σ.
This function does not consider the likelihood of the initial conditiion x₁,x₂...xₚ)
"""
function Opp_LL_Monthly_Multi_AR!(Estimators::AbstractMatrix, tuple_)
    x, n2m = tuple_
    n, d = size(x)
    p = (2 * size(Estimators)[2] - d^2 - d) ÷ (2 * d^2)
    @views Φ = [[stack(Estimators[m, (j*(d^2)+1+i*d):(j*(d^2)+(i+1)*d)] for i in 0:(d-1)) for j in 0:(p-1)] for m in 1:12]
    Indexes = [0; cumsum(d:-1:1)]

    Σ = [FillByDiags!(Estimators[m, (p*d^2+1):end], Indexes, d) for m in 1:12]
    Varcov = [Mat * transpose(Mat) for Mat in Σ]
    InvVarcov = inv.(Varcov)
    cte = d .* log(2π) .+ log.(abs.(det.(Varcov)))

    EV = [sum(Φ[n2m[t]][j] * view(x,t-j, :) for j in 1:p) for t in (p+1):n]
    Opplogpdf(t) = (cte[n2m[t]] + transpose(view(x,t, :) - EV[t-p]) * InvVarcov[n2m[t]] * (view(x,t, :) - EV[t-p])) / 2
    return Opplogpdf, p, n
end


function Opp_LL_Monthly_Multi_AR(Estimators::AbstractMatrix, tuple_)
    Opplogpdf, p, n = Opp_LL_Monthly_Multi_AR!(Estimators, tuple_)
    return sum(Opplogpdf.((p+1):n))
end

"""
    LL_Multi_AR_Estimation(x::AbstractVector,p::Integer)

Return the parameters of the AR(p) model on x, estimated with likelihood computation.
Estimators correspond to the initialization of the algorithm.
"""
function LL_Multi_AR_Estimation_monthly(x::AbstractArray, date_vec::AbstractVector{Date}, p::Integer, Estimators=nothing, algo=LBFGS())
    d = size(x)[2]
    InitΣ = [1e-5 * ones(d); 1e-15 * ones(d * (d - 1) ÷ 2)]
    isnothing(Estimators) ? Estimators = stack([[0.5 for _ in 1:p*d^2]; InitΣ] for _ in 1:12; dims=1) : nothing
    # p == length(Estimators) - 1 ? nothing : error("p (=$(p)) is not equal to the number of Φ initial parameters (=$(length(Estimators)-1))")
    optf = OptimizationFunction(Opp_LL_Monthly_Multi_AR, AutoForwardDiff())
    prob = OptimizationProblem(optf, Estimators, (x, month.(date_vec)),
        lb=stack([[-10 for _ in 1:p*d^2]; [1e-20 for _ in 1:(d*(d+1)÷2)]] for _ in 1:12; dims=1),
        ub=stack([[10 for _ in 1:p*d^2]; [1e2 for _ in 1:(d*(d+1)÷2)]] for _ in 1:12; dims=1))
    Results = Optimization.solve(prob, algo) #maxiters should be modified if needed
    return Results
end

#######

function ParseMonthlyParameter(Param, d)
    p = (2 * size(Param)[2] - d^2 - d) ÷ (2 * d^2)

    Φ = [[stack(Param[m, (j*(d^2)+1+i*d):(j*(d^2)+(i+1)*d)] for i in 0:(d-1)) for j in 0:(p-1)] for m in 1:12] #12-element Vector{Vector{Matrix{Float64}}} ~16 min

    Indexes = [0; cumsum(d:-1:1)]
    Σ = [FillByDiags!(Param[m, (p*d^2+1):end], Indexes, d) for m in 1:12]

    return Φ, Σ
end

TakeMonthlyParameter(MatVec::Vector{Vector{Matrix{T}}}, IndexTuple, p=1) where T<:AbstractFloat = [MatVec[m][p][IndexTuple[1], IndexTuple[2]] for m in 1:12]
TakeMonthlyParameter(MatVec::Vector{Matrix{T}}, IndexTuple) where T<:AbstractFloat = [MatVec[m][IndexTuple[1], IndexTuple[2]] for m in 1:12]


# FlatΦ(Φ,d=2) = vcat([hcat([reshape(v_sub,(1,d^2)) for v_sub in Φ[m]]...) for m in 1:12]...)
# Flatσ(σ,d=2) = vcat([reshape(σ[m],(1,d^2)) for m in 1:12]...)